# 什么是路径遍历？ 

​        路径遍历也称为目录遍历。这些漏洞使攻击者能够读取运行应用程序的服务器上的任意文件。这可能包括：     

- ​            应用程序代码和数据。         
- ​            后端系统的凭据。         
- ​            敏感的操作系统文件。         

​        在某些情况下，攻击者可能能够写入服务器上的任意文件，从而允许他们修改应用程序数据或行为，并最终完全控制服务器。     

# 通过路径遍历读取任意文件 

​    假设有一个购物应用程序，它显示待售商品的图像。这可能会使用以下 HTML 加载图像： 

> <img src="/loadImage?filename=218.png">

​    这  `loadImage` URL 采用  `filename` 参数并返回指定文件的内容。图像文件存储在磁盘上的位置  `/var/www/images/`。要返回图像，应用程序会将请求的文件名附加到此基目录，并使用文件系统 API 读取文件的内容。换句话说，应用程序从以下文件路径读取： 

```
/var/www/images/218.png
```

​    此应用程序不实施对路径遍历攻击的防御。因此，攻击者可以请求以下 URL 来检索  `/etc/passwd` 文件： 

```
https://insecure-website.com/loadImagefilename=../../../etc/passwd
```

​    这会导致应用程序从以下文件路径读取： 

```
/var/www/images/../../../etc/passwd
```

~~使用../进行目录遍历访问任意文件~~    

序列  `../` 在文件路径中有效，表示在目录结构中上升一级。连续三个  `../` 序列从  `/var/www/images/` 到文件系统根目录，因此实际读取的文件是： 

```
/etc/passwd
```

​    在基于 Unix 的操作系统上，这是一个标准文件，其中包含服务器上注册的用户的详细信息，但攻击者可以使用相同的技术检索其他任意文件。 

​    在 Windows 上，两者  `../` 和  `..\` 是有效的**目录遍历序列**。以下是针对基于 Windows 的服务器的等效攻击示例： 

```
https://insecure-website.com/loadImage?filename=..\..\..\windows\win.ini
```

# 利用路径遍历漏洞的常见障碍 

许多将用户输入到文件路径中的应用程序都实施了针对路径遍历攻击的防御。这些通常可以绕过。 

如果应用程序从用户提供的文件名**剥离或阻止目录遍历序列**，则可以使用各种技术绕过防御。 

您可以**使用文件系统根目录中的绝对路径**，例如  `filename=/etc/passwd`直接引用文件，而无需使用任何遍历序列。

~~lab文件路径遍历，被绝对路径旁路阻塞的遍历序列~~

~~使用绝对路径直接引用文件~~ 

您或许能够使用**嵌套遍历序列**，例如  `....//` 或  `....\/`。当内部序列被剥离时，这些将恢复为简单的遍历序列。 

~~lab文件路径遍历，非递归剥离的遍历序列~~

~~使用嵌套遍历绕过目录序列剥离，如....//....//....//etc/passwd，若此方法显示行得通，可通过多次尝试不同嵌套组合总结规律实现正确绕过~~

在某些上下文中，例如在 URL 路径或  `filename` 参数的  `multipart/form-data` 请求时，Web 服务器可能会在将你的输入传递给应用程序之前去除任何目录遍历序列。有时，您可以通过 **URL 编码甚至双重 URL 编码**来绕过这种清理，即  `../` 字符。这导致  `%2e%2e%2f` 和  `%252e%252e%252f` 分别。各种**非标准编码**，例如  `..%c0%af` 或  `..%ef%bc%8f`，也可能有效。 

对于 Burp Suite Professional 用户，Burp Intruder 提供了预定义的负载列表  **Fuzzing - path traversal** 。这包含一些您可以尝试的编码路径遍历序列。 

~~lab文件路径遍历，用多余的URL解码的遍历序列~~

~~通过URL编码和双重URL编码和非标准编码绕过，它们的绕过原理在文件上传漏洞的记录中有解释，形如..%252f..%252f..%252fetc/passwd~~

应用程序可能要求用户提供的文件名以预期的 base 文件夹开头，例如  `/var/www/images`。在这种情况下，可以包含所需的 base 文件夹，后跟适当的遍历序列。例如：  `filename=/var/www/images/../../../etc/passwd`。 

应用程序可能要求用户提供的文件名以**预期的文件扩展名结尾**，例如  `.png`。在这种情况下，可以使用 **null 字节来有效地终止所需扩展名之前的文件路径**。例如：  `filename=../../../etc/passwd%00.png`。 

# 如何防止路径遍历攻击 

​    防止路径遍历漏洞的最有效方法是完全避免将用户提供的输入传递给文件系统 API。许多执行此操作的应用程序函数可以重写，以更安全的方式提供相同的行为。 

​    如果您无法避免将用户提供的输入传递给文件系统 API，我们建议使用两层防御来防止攻击： 

- ​        在处理用户输入之前对其进行验证。理想情况下，将用户输入与允许的值白名单进行比较。如果无法做到这一点，请验证输入是否仅包含允许的内容，例如仅字母数字字符。     
- ​        验证提供的输入后，将输入附加到基目录，并使用平台文件系统 API 对路径进行规范化。验证规范化路径是否以预期的基目录开头。     

​    下面是一些简单的 Java 代码示例，用于根据用户输入验证文件的规范路径： 

```
File file = new File(BASE_DIRECTORY, userInput); if (file.getCanonicalPath().startsWith(BASE_DIRECTORY)) {    // process file }
```